<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sicheng Lv&#39;s blog</title>
  <subtitle>静止了所有的花开，你好久都没有再来 、</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sichenglv.github.io/"/>
  <updated>2016-11-03T07:54:25.912Z</updated>
  <id>https://sichenglv.github.io/</id>
  
  <author>
    <name>sicheng Lv</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下C/C++正则表达式详解</title>
    <link href="https://sichenglv.github.io/2016/11/02/linux%E4%B8%8BC-C-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://sichenglv.github.io/2016/11/02/linux下C-C-正则表达式详解/</id>
    <published>2016-11-02T13:07:25.000Z</published>
    <updated>2016-11-03T07:54:25.912Z</updated>
    
    <content type="html"><![CDATA[<p>标准的C和C++都不支持正则表达式，但有一些函数库可以辅助C/C++程序员完成这一功能，其中最著名的当数Philip Hazel的Perl-Compatible Regular Expression库，许多Linux发行版本都带有这个函数库。以POSIX函数库中的Regex系列函数来说明在Linux C下如何使用正则表达式</p>
<p>C语言处理正则表达式常用的函数有regcomp()、regexec()、regfree()和regerror()，一般分为三个步骤，如下所示：</p>
<h3 id="C语言中使用正则表达式一般分为三步："><a href="#C语言中使用正则表达式一般分为三步：" class="headerlink" title="C语言中使用正则表达式一般分为三步："></a>C语言中使用正则表达式一般分为三步：</h3><blockquote>
<p>编译正则表达式 regcomp()</p>
<p>匹配正则表达式 regexec()</p>
<p>释放正则表达式 regfree()</p>
</blockquote>
<h4 id="1、编译正则表达式："><a href="#1、编译正则表达式：" class="headerlink" title="1、编译正则表达式："></a>1、编译正则表达式：</h4><blockquote>
<p>int Regcomp(regex_t <em>compiled, const char </em>pattern, int cflags);</p>
</blockquote>
<p>这个函数把指定的正则表达式pattern编译成一种特定的数据格式compiled，这样可以使匹配更有效。函数regexec 会使用这个数据在目标文本串中进行模式匹配。执行成功返回０。</p>
<p><strong> 参数说明：</strong><br>　　①compiled: regex_t 是一个结构体数据类型，用来存放编译后的正则表达式，它的成员re_nsub 用来存储正则表达式中的子正则表达式的个数，子正则表达式就是用圆括号包起来的部分表达式。</p>
<p>　　②pattern: 指向我们写好的正则表达式的指针。</p>
<p>　　③cflags: 编译开关控制细节，有如下4个值或者是它们或运算(|)后的值：<br>　　　　　REG_EXTENDED 以功能更加强大的扩展正则表达式的方式进行匹配。<br>　　　　　REG_ICASE 匹配字母时忽略大小写。<br>　　　　　REG_NOSUB 不用存储匹配后的结果。<br>　　　　　REG_NEWLINE 识别换行符，这样’$’就可以从行尾开始匹配，’^’就可以从行的开头开始匹配。</p>
<hr>
<h4 id="2、匹配正则表达式："><a href="#2、匹配正则表达式：" class="headerlink" title="2、匹配正则表达式： **"></a>2、匹配正则表达式： **</h4><blockquote>
<p>int regexec(regex_t <em>compiled, char </em>string, size_t nmatch, regmatch_t pmatch [], int eflags);</p>
</blockquote>
<p>当我们编译好正则表达式后，就可以用regexec 匹配我们的目标文本串了，如果在编译正则表达式的时候没有指定cflags的参数为REG_NEWLINE，则默认情况下是忽略换行符的，也就是把整个文本串当作一个字符串处理。执行成功返回０。</p>
<p>regmatch_t 是一个结构体数据类型，在regex.h中定义：<br>typedef struct<br>{<br>   regoff_t rm_so;<br>   regoff_t rm_eo;<br>} regmatch_t;</p>
<p>成员rm_so 存放匹配文本串在目标串中的开始位置，rm_eo 存放结束位置。通常我们以数组的形式定义一组这样的结构。因为往往我们的正则表达式中还包含子正则表达式。数组0单元存放主正则表达式位置，后边的单元依次存放子正则表达式位置。</p>
<p><strong> 参数说明：</strong><br>　　①compiled: 是已经用regcomp函数编译好的正则表达式。</p>
<p>　　②string: 是待匹配的字符串。</p>
<p>　　③nmatch: 是regmatch_t结构体数组的长度，被匹配的个数。</p>
<p>　　④pmatch: 匹配的结果数组。</p>
<p>　　⑤eflags: 匹配的特性<br>　　　　　REG_NOTBOL 是否是第一行<br>      REG_NOTEOL 是否是最后一行</p>
<hr>
<h4 id="3、释放正则表达式："><a href="#3、释放正则表达式：" class="headerlink" title="3、释放正则表达式： **"></a>3、释放正则表达式： **</h4><blockquote>
<p>void regfree(regex_t *compiled);</p>
</blockquote>
<p>当我们使用完编译好的正则表达式后，或者要重新编译其他正则表达式的时候，我们可以用这个函数清空compiled指向的regex_t结构体的内容，<strong> 请记住，如果是重新编译的话，一定要先清空regex_t结构体。</strong></p>
<h4 id="4、报告错误信息："><a href="#4、报告错误信息：" class="headerlink" title="4、报告错误信息："></a>4、报告错误信息：</h4><blockquote>
<p>size_t regerror(int errcode, regex_t <em>compiled, char </em>buffer, size_t length);</p>
</blockquote>
<p>当执行regcomp 或者regexec 产生错误的时候，就可以调用这个函数而返回一个包含错误信息的字符串。</p>
<p><strong> 参数说明：</strong><br>　　①errcode 是由regcomp 和 regexec 函数返回的错误代号。</p>
<p>　　②compiled 是已经用regcomp函数编译好的正则表达式，这个值可以为NULL。</p>
<p>　　③buffer 指向用来存放错误信息的字符串的内存空间。</p>
<p>　　④length 指明buffer的长度，如果这个错误信息的长度大于这个值，则regerror 函数会自动截断超出的字符串，但他仍然会返回完整的字符串的长度。所以我们可以用如下的方法先得到错误字符串的长度。<br>　　size_t length = regerror (errcode, compiled, NULL, 0);</p>
<hr>
<h4 id="5、正则表达式框架："><a href="#5、正则表达式框架：" class="headerlink" title="5、正则表达式框架："></a>5、正则表达式框架：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">int mymatch(char *buf)</div><div class="line">&#123;</div><div class="line">    const char *pattern = &quot;&quot;;</div><div class="line">    regex_t reg;</div><div class="line">    </div><div class="line">    regmatch_t pmatch[10];</div><div class="line">    const size_t nmatch = 10;</div><div class="line"></div><div class="line">    int cflag = REG_EXTENDED;</div><div class="line"></div><div class="line">    /* 编译正则表达式 */</div><div class="line">    if(regcomp(&amp;reg, pattern, cflag) != 0) &#123;  //如果编译正则表达式失败</div><div class="line">       perror(&quot;regcomp failed!&quot;);</div><div class="line">       exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int status, i;</div><div class="line">    /* 执行匹配 */</div><div class="line">    status = regexec(&amp;reg, buf, nmatch, pmatch, 0);</div><div class="line">    if(status == REG_NOMATCH) &#123;</div><div class="line">       printf(&quot;No Match\n&quot;);</div><div class="line">       return 0;</div><div class="line">    &#125;</div><div class="line">    else if(status == 0) &#123;</div><div class="line">       printf(&quot;Match: \n&quot;);</div><div class="line">       /* 把匹配的字符串都提取出来 */</div><div class="line">       for(i = 0; i &lt; nmatch &amp;&amp; pmatch[i].rm_so != -1; i++) &#123;</div><div class="line"></div><div class="line">           //对匹配的字符串进行的操作</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    regfree(&amp;reg); //释放正则表达式</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="6、正则表达式实例："><a href="#6、正则表达式实例：" class="headerlink" title="6、正则表达式实例："></a>6、正则表达式实例：</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标准的C和C++都不支持正则表达式，但有一些函数库可以辅助C/C++程序员完成这一功能，其中最著名的当数Philip Hazel的Perl-Compatible Regular Expression库，许多Linux发行版本都带有这个函数库。以POSIX函数库中的Regex
    
    </summary>
    
    
      <category term="正则表达式" scheme="https://sichenglv.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="C/C++" scheme="https://sichenglv.github.io/tags/C-C/"/>
    
      <category term="Linux" scheme="https://sichenglv.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ZJU-1206 Win the Bonus</title>
    <link href="https://sichenglv.github.io/2016/10/22/ZOJ-1206-Win-the-Bonus/"/>
    <id>https://sichenglv.github.io/2016/10/22/ZOJ-1206-Win-the-Bonus/</id>
    <published>2016-10-22T11:28:36.000Z</published>
    <updated>2016-10-23T03:53:54.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p><strong> 原题链接: </strong><a href="http://acm.hrbust.edu.cn/vj/index.php?c=problem-problem&amp;id=26497" target="_blank" rel="external">ZJU 1206</a> </p>
<p>给出 m个长度为3的由 0~9组成的字符串，每个字符串有一个权值，可正可负。</p>
<p>要求构造出一个长度为n的字符串，若字符串中包含题目给出的某个字符串，则获得该字符串的权值。</p>
<p>求一个权值最大的字符串。</p>
</blockquote>
<p><strong> 输入样例： </strong></p>
<pre><code>2 5

356 20

674 -10
</code></pre><p><strong> 输出样例：</strong></p>
<pre><code>00356
</code></pre><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><blockquote>
<p>于 n多达 10 000位，枚举和搜索方法都很容易实现超时。</p>
<p>如果前 k位数字串能够得到最优值，则构成 k+1(k~[3,n])位时肯定也能得到最优值。</p>
<p>所以本题具有最优子结构，可使用动态规划算法求解。</p>
</blockquote>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>设银行职员的人数为m，玩家的字符串长度为n</p>
<p><strong> int banker, point;  //每个银行职员的数字串及相应的分值 </strong></p>
<p><strong> int cost[1000];  //存放银行职员的数字串及相应的分值，数字串的长度为3 </strong></p>
<p>//三维数组，opt[l][i][j]表示：当前长度为 l(l~[3-10000])的数字串，第一位数字是 i，第二位数字是 j(i,j~[1-9])的最优值 </p>
<p><strong> int opt[10001][10][10]; </strong></p>
<p><strong> 边界条件 </strong></p>
<p>当数字串长度为 1,2时，最优值为0</p>
<p>即opt[l][i][j] = 0; (l=1,2; i,j~[0-9])</p>
<p><strong> 递推公式 </strong></p>
<p>从右往左dp,只有这样才能保证最后得出的字符串是字典序最小的, ijk组成一个数字串</p>
<p><strong> opt[l][i][j] = max {opt[l-1][j][k] + cost[i<em>100+j</em>10+k]}  (k~[3,n], i,j~[0-9]) </strong></p>
<p><strong> 辅助数组 </strong></p>
<p>int path[10001][10][10];  //记录 k值 </p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h3 id="dp算法的实现"><a href="#dp算法的实现" class="headerlink" title="dp算法的实现"></a>dp算法的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">void DP(int n) </div><div class="line">&#123;</div><div class="line">	int l, i, j, k;</div><div class="line">	int max = 0;</div><div class="line">	//边界条件 ,只有一个字符和两个字符 </div><div class="line">	for(l = 1; l &lt;= 2; l++)</div><div class="line">		for(i = 0; i &lt;= 9; i++)</div><div class="line">			for(j = 0; j &lt;= 9; j++)</div><div class="line">				opt[l][i][j] = 0;</div><div class="line">	//递推计算3-n个字符时的最优值 </div><div class="line">	for(l = 3; l &lt;= n; l++)</div><div class="line">		for(i = 0; i &lt;= 9; i++)</div><div class="line">			for(j = 0; j &lt;= 9; j++)</div><div class="line">			&#123;</div><div class="line">				//长度为 l个字符时，计算由 ijk构成数字串的最优值</div><div class="line">				 opt[l][i][j] = -INF;</div><div class="line">				 for(k = 0; k &lt;= 9; k++) &#123;</div><div class="line">				 	max = opt[l-1][j][k] + cost[i*100+j*10+k];	//从右往左dp</div><div class="line">				 	if(max &gt; opt[l][i][j])</div><div class="line">				 	&#123;</div><div class="line">				 		opt[l][i][j] = max;</div><div class="line">				 		path[l][i][j] = k;</div><div class="line">				 	&#125;</div><div class="line">				 &#125;</div><div class="line">			&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造最优解，返回最优值"><a href="#构造最优解，返回最优值" class="headerlink" title="构造最优解，返回最优值"></a>构造最优解，返回最优值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">int traceback(int n)</div><div class="line">&#123;</div><div class="line">	int i, j;</div><div class="line">	int p, q;		//记录最优值对应数字串的第一第二个数字 </div><div class="line">	int ans = -INF;	//最优值 </div><div class="line">	</div><div class="line">	for(i = 0; i &lt;= 9; i++)</div><div class="line">		for(j = 0; j &lt;= 9; j++)</div><div class="line">		&#123;</div><div class="line">			if(opt[n][i][j] &gt; ans)</div><div class="line">			&#123;</div><div class="line">				ans = opt[n][i][j];</div><div class="line">				p = i;</div><div class="line">				q = j;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	for(i = n; i &gt;= 3; i--)</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; p;</div><div class="line">		int k = path[i][p][q];	//找到后一个数字 </div><div class="line">		p = q;</div><div class="line">		q = k;	</div><div class="line">	&#125;	</div><div class="line">	//输出最后两位数字</div><div class="line">	cout &lt;&lt; p &lt;&lt; q &lt;&lt; endl; </div><div class="line">	return ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	freopen(&quot;zoj1206.txt&quot;, &quot;r&quot;, stdin);</div><div class="line">	</div><div class="line">	int m, n;	// m是银行职员的人数，n是玩家数字串长度 </div><div class="line">	int banker, point;</div><div class="line">	cin &gt;&gt; m &gt;&gt; n;</div><div class="line">	</div><div class="line">	int i;</div><div class="line">	for(i = 0; i &lt; m; i++) &#123;</div><div class="line">		cin &gt;&gt; banker &gt;&gt; point;</div><div class="line">		cost[banker] = point;		//将分值存入以银行职员的数字串为下标的元素中 </div><div class="line">	&#125;</div><div class="line">	//调用dp算法</div><div class="line">	DP(n) ;</div><div class="line">	//输出最优解</div><div class="line">	cout &lt;&lt; &quot;获胜字符串为：&quot;;</div><div class="line">	int ans = traceback(n);</div><div class="line">	cout &lt;&lt; &quot;最优值为：&quot; &lt;&lt; ans &lt;&lt; endl; </div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt; 原题链接: &lt;/strong&gt;&lt;a href=&quot;http://acm.hrbus
    
    </summary>
    
    
      <category term="动态规划" scheme="https://sichenglv.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="dp" scheme="https://sichenglv.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>POJ-1050 To the Max</title>
    <link href="https://sichenglv.github.io/2016/10/09/POJ-1050-To-the-Max/"/>
    <id>https://sichenglv.github.io/2016/10/09/POJ-1050-To-the-Max/</id>
    <published>2016-10-09T01:21:42.000Z</published>
    <updated>2016-10-16T08:27:38.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划-——-最大子矩阵和"><a href="#动态规划-——-最大子矩阵和" class="headerlink" title="动态规划 —— 最大子矩阵和"></a>动态规划 —— 最大子矩阵和</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><blockquote>
<p>给你一个N*N的矩阵，要求找出其一个子矩阵，使其各元素之和为最大。<br>原题地址: <a href="http://poj.org/problem?id=1050" target="_blank" rel="external">POJ-1050 To the Max</a></p>
</blockquote>
<h2 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h2><blockquote>
<ol>
<li>首先要学会最大子段和的求法(这道题的动态规划思想就体现在这里)</li>
<li>利用求最大子段和的算法，<strong> 将二维动态规划问题转化为一维动态规划问题 </strong><br>设一维数组b是二维数组a的i~j(0&lt;=i&lt;j&lt;n)行，对应列元素的和，然后对数组b计算最大子段和。</li>
<li>构造最优解</li>
</ol>
</blockquote>
<h2 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h2><p><strong> 计算最大子段和算法 </strong></p>
<pre><code>/* besti, bestj 记录最大子段和的范围，用于构造最优解 */
int DP(int a[], int n, int&amp; besti, int&amp; bestj)
{
    int i;
    int max = -200000000;

    //当b[i-1]&lt;=0时，记录b[i]=a[i]的位置
    int begin = 0;
    for(i = 1 ; i &lt;= n ; i++ )
    {
        if (b &gt; 0)
            b += a[i];
        else
        {
            b = a[i];
            begin = i;        //新的起始边界
        }
        if (b &gt; max)
        {
            max = b;
            besti = begin;
            bestj = i;        //更新左右边界
        }
    }
    return max;
}
</code></pre><p><strong> 计算最大子矩阵和的动态规划算法 </strong></p>
<pre><code>#define N 101
int main()
{
    int a[N][N];            // N*N矩阵 
    int sum[N];             // 一维数组 

    //构造最优解
    int rowI = 0;            //最大子矩阵的行号
    int rowJ = 0;            //最大子矩阵的行号
    int col = 0;             //最大子矩阵的列号

    int n;
    cin &gt;&gt; n;
    int i, j, k;
    for(i = 1; i &lt;= n; i++)
        for(j = 1; j &lt;= n; j++)
            cin &gt;&gt; a[i][j];

    int max = -128;
    for( i = 1 ; i &lt;= n ; i++ )
    {
        memset(sum, 0, sizeof(sum));        //数组置零
        for(j = i ; j &lt;= n ; j++ )
        {
            for( k = 1 ; k &lt;= n ; k++ )
                sum[k] += a[j][k];    //取出第 i, j两行，将这两行之间的列对应相加，形成另外一个数组sum，对数组 sum求最大子段和
            int maxSum = DP(sum, n);
            if(maxSum &gt; max)                //找出最大子矩阵和
            {
                rowI = i;
                rowJ = j;
                col = bestj;                //记录子矩阵的位置
                max = maxSum;
            }
        }
    }
    cout &lt;&lt; max &lt;&lt; endl;                    //输出最大子矩阵和

    /* 构造最优解: 打印出最大和的子矩阵 */
    for(i = rowI; i &lt;= rowJ; i++)
    {
        for(j = 1; j &lt;= col; j++)
        {
            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p><strong> 可以将以上代码简化 </strong></p>
<pre><code>#define N 101
int main()
{
    int a[N][N];        // N*N矩阵 
    int b[N];             // 一维数组 

    //构造最优解
    int rowI = 0;        //最大子矩阵的行号
    int rowJ = 0;        //最大子矩阵的行号
    int col = 0;         //最大子矩阵的列号

    int n;
    cin &gt;&gt; n;

    int max = -128;
    for( i = 1; i &lt;= n; i++ )
    {
        memset(b, 0, sizeof(b));        //数组置零
        for(j = i; j &lt;= n; j++ )
        {
            //下面是针对数组b求最大子段和的算法 
            int sum = 0; 
            for( k = 1; k &lt;= n; k++ )
            {
                b[k] += a[j][k];
                sum += b[k];
                if(sum &lt; b[k]) sum = b[k];
                if(sum &gt; max)                //找出最大子矩阵和
                {
                    rowI = i;
                    rowJ = j;
                    col = bestj;            //记录子矩阵的位置
                    max = sum;
                }
            }

        }
    }
    cout &lt;&lt; max &lt;&lt; endl;                    //输出最大子矩阵和

    return 0;
}
</code></pre><h2 id="算法的时间复杂度："><a href="#算法的时间复杂度：" class="headerlink" title="算法的时间复杂度："></a>算法的时间复杂度：</h2><blockquote>
<p>有三重循环，时间复杂度为O(n^3)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划-——-最大子矩阵和&quot;&gt;&lt;a href=&quot;#动态规划-——-最大子矩阵和&quot; class=&quot;headerlink&quot; title=&quot;动态规划 —— 最大子矩阵和&quot;&gt;&lt;/a&gt;动态规划 —— 最大子矩阵和&lt;/h1&gt;&lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
    
      <category term="algorithm" scheme="https://sichenglv.github.io/tags/algorithm/"/>
    
      <category term="动态规划" scheme="https://sichenglv.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>MatrixChain</title>
    <link href="https://sichenglv.github.io/2016/10/07/MatrixChain/"/>
    <id>https://sichenglv.github.io/2016/10/07/MatrixChain/</id>
    <published>2016-10-07T03:08:19.000Z</published>
    <updated>2016-10-16T06:55:08.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划-——-矩阵连乘积问题"><a href="#动态规划-——-矩阵连乘积问题" class="headerlink" title="动态规划 —— 矩阵连乘积问题"></a>动态规划 —— 矩阵连乘积问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><blockquote>
<p>给定n个矩阵{A1,A2,…,An}，其中Ai和Ai+1是可乘的，i=1，2…，n-1。确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。</p>
</blockquote>
<h2 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h2><h3 id="问题的解空间："><a href="#问题的解空间：" class="headerlink" title="问题的解空间："></a>问题的解空间：</h3><blockquote>
<p>n个矩阵可能的完全加括号方式有P(n)=Catalan(n-1)，所以P(n)是随n的指数级增长的，因此穷举法不是一个有效的算法。</p>
</blockquote>
<h3 id="最优子结构："><a href="#最优子结构：" class="headerlink" title="最优子结构："></a>最优子结构：</h3><blockquote>
<p> 设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]。</p>
<p>当i=j时，A[i:j]=Ai，因此，m[i][i]=0，i=1,2,…,n</p>
<p>当i&lt;j时，若A[i:j]的最优次序在Ak和Ak+1之间断开，i&lt;=k&lt;j,则：m[i][j]=m[i][k]+m[k+1][j]+pi-1pkpj。</p>
<p>由于在计算是并不知道断开点k的位置，所以k还未定。不过k的位置只有j-i个可能。因此，k是这j-i个位置使计算量达到最小的那个位置。</p>
<blockquote>
<p>递归的定义最优解<br><img src="http://i.imgur.com/UK0G4Fo.jpg" alt=""></p>
</blockquote>
</blockquote>
<h3 id="重叠子问题："><a href="#重叠子问题：" class="headerlink" title="重叠子问题："></a>重叠子问题：</h3><blockquote>
<p>一般取原问题规模为4-6的来验证是否存在重叠子问题<br><img src="http://i.imgur.com/nxpDdiH.jpg" alt=""></p>
</blockquote>
<h3 id="根据动态规划方程设计数据结构："><a href="#根据动态规划方程设计数据结构：" class="headerlink" title="根据动态规划方程设计数据结构："></a>根据动态规划方程设计数据结构：</h3><blockquote>
<p>1)很显然这里使用二维数组，然后根据递归方程的特点确定填表的方式，这里采用 <strong> 对角线填法</strong><br>2)<strong> 填充顺序原则：</strong> 要保证当前填充的这个格子的子问题都已经计算出来了。</p>
</blockquote>
<h3 id="计算最优值"><a href="#计算最优值" class="headerlink" title="计算最优值"></a>计算最优值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* 计算矩阵连乘积的动态规划算法 */</div><div class="line">#define N 51</div><div class="line"></div><div class="line">int p[N];		//存放矩阵的阶 </div><div class="line">int m[N][N];	//m[i][j]代表A[i,j]最少的乘法次数, 即最优值 </div><div class="line">int s[N][N];	//s[i][j]代表A[i,j]的最优次序中的断开位置 k, 根据s[i][j]的值可构造出相应的最优解</div><div class="line"></div><div class="line">void MatrixChain(int n)		//n表示矩阵个数 </div><div class="line">&#123;</div><div class="line">	for(int i = 1; i &lt;= n; i++)</div><div class="line">	&#123;</div><div class="line">		m[i][i] = 0;	//r = 1, 只有一个矩阵的情况 </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	// 填表：对角线填法 </div><div class="line">	// r表示矩阵链的长度 </div><div class="line">	for(int r = 2; r &lt;= n; r++)</div><div class="line">	&#123;</div><div class="line">		for(int i = 1; i &lt;= n-r+1; i++)	// n-r+1是对角线的长度 </div><div class="line">		&#123;</div><div class="line">			int j = i + r - 1;			//i, j表示对角线的下标 </div><div class="line">			m[i][j] = 2000000000;</div><div class="line">			//搜寻最优值 </div><div class="line">			for(int k = i; k &lt; j; k++)	//寻找代价最小的那个 k </div><div class="line">			&#123;</div><div class="line">				int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];</div><div class="line">				if( t &lt; m[i][j] )</div><div class="line">				&#123;</div><div class="line">					m[i][j] = t;		//保存最优值 </div><div class="line">					s[i][j] = k;		//记录最优值的那个k </div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造最优解"><a href="#构造最优解" class="headerlink" title="构造最优解"></a>构造最优解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* 构造最优解 */</div><div class="line">void TrackBack(int i, int j)</div><div class="line">&#123;</div><div class="line">	if( i == j )</div><div class="line">		printf(&quot;A%d&quot;, i);</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;(&quot;;</div><div class="line">		TrackBack(i, s[i][j]);</div><div class="line">		TrackBack(s[i][j]+1, j);</div><div class="line">		cout &lt;&lt; &quot;)&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自顶向下的递归算法-备忘录"><a href="#自顶向下的递归算法-备忘录" class="headerlink" title="自顶向下的递归算法(备忘录)"></a>自顶向下的递归算法(备忘录)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#define N 51</div><div class="line">int p[N];		//存放矩阵的阶 </div><div class="line">int m[N][N];	//m[i][j]代表A[i,j]最少的乘法次数, 即最优值 </div><div class="line">int s[N][N];	//s[i][j]代表A[i,j]的最优次序中的断开位置 k, 根据s[i][j]的值可构造出相应的最优解</div><div class="line"></div><div class="line">int Recurve(int i, int j)</div><div class="line">&#123;</div><div class="line">	if(m[i][j] &gt; 0)</div><div class="line">		return m[i][j];</div><div class="line">	if(i == j)</div><div class="line">		return 0;</div><div class="line">		</div><div class="line">	int u = Recurve(i, i) + Recurve(i+1, j) + p[i-1] * p[i] * p[j];</div><div class="line">	s[i][j] = i;</div><div class="line">	</div><div class="line">	for(int k = i+1; k &lt; j; k++)</div><div class="line">	&#123;</div><div class="line">		int t = Recurve(i, k) + Recurve(k+1, j) + p[i-1] * p[k] * p[j];</div><div class="line">		if(t &lt; u)</div><div class="line">		&#123;</div><div class="line">			u = t;</div><div class="line">			s[i][j] = k;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	m[i][j] = u;	//将结果存入备忘录 </div><div class="line">	return u;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="两种算法的比较与总结"><a href="#两种算法的比较与总结" class="headerlink" title="两种算法的比较与总结"></a>两种算法的比较与总结</h2><blockquote>
<p>动态规划算法采用的是自底向上的非递归式</p>
<p>备忘录方法采用的是自顶向下的递归方式</p>
<p>两者的时间复杂度都是O(n^3)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划-——-矩阵连乘积问题&quot;&gt;&lt;a href=&quot;#动态规划-——-矩阵连乘积问题&quot; class=&quot;headerlink&quot; title=&quot;动态规划 —— 矩阵连乘积问题&quot;&gt;&lt;/a&gt;动态规划 —— 矩阵连乘积问题&lt;/h1&gt;&lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a hre
    
    </summary>
    
    
      <category term="algorithm" scheme="https://sichenglv.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
